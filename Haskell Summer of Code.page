As part of Google's [Summer of code](!Wikipedia "Google Summer of Code") ([homepage](http://code.google.com/soc/)) program, Google sponsors 5-10 [projects for Haskell](http://hackage.haskell.org/trac/summer-of-code/).

The Haskell Summer of Codes have often produced excellent results, but how excellent is excellent? Are there any features or commonalities between successful projects or unsuccessful ones?

(This questions are particularly important as SoC 2011 is just a few months away - students apply in late March.)

## Example retrospective: Debian

An energetic blogger & Debian developer has produced [a](http://www.milliways.fr/2009/01/20/debian-2008-where-now-1/) [three](http://www.milliways.fr/2009/01/28/debian-2008-where-now-2/) [part](http://www.milliways.fr/2009/02/02/debian-2008-where-now-3/) series on the many Debian-related Summer of Code projects.

The results are interesting: some projects were a failure and the relevant student drifted away and had little to do with Debian again; and some were great successes. I don't discern any particular lessons there, except perhaps one against hubris or filling unclear needs. Let's see whether that holds true of Haskell.

## Haskell retrospective

Haskell wasn't part of the first Summer of Code in 2005, but it was accepted for 2006. We start there.

### 2006

The 2006 [homepage](http://hackage.haskell.org/trac/summer-of-code/wiki/SoC2006) lists the following projects:

- "Fast Mutable Collection Types for Haskell"; Caio Marcelo de Oliveira Filho, mentored by Audrey Tang

    **unsuccessful**. This ultimately resulted in the [HsJudy](!Hackage) library ('fast mutable collection' here meaning 'array'). HsJudy was apparently used in Pugs at one time, but no more.
- "Port Haddock to use GHC"; David Waern, mentored by Simon Marlow

       **Successful**. Haddock has used the GHC API ever since.[^complaints]
- "A model for client-side scripts with HSP"; Joel Björnson, mentored by Niklas Broberg

    **Successful?** Was initially unsuccessful, but seems to've been picked up again.
- "GHCi based debugger for Haskell"; José Iborra López, mentored by David Himmelstrup

    **Successful**. The GHCi debugger was accepted into GHC HEAD, and by now is in production use,
- "HaskellNet"; Jun Mukai, mentored by Shae Erisson

    **Unsuccessful**. HaskellNet is dead, and nothing of it has propagated elsewhere. (I'm not entirely sure what happened with the HaskellNet code - I know of [two](https://patch-tag.com/r/wrwills/HaskellNet/home) [repos](http://stuff.mit.edu/afs/sipb/project/suez/src/haskell/haskellnet/), but that's about it.) Shae tells me that this poor uptake is probably due to a lack of advertising, and not any actual defect in the HaskellNet code.
- "Language.C - a C parser written in Haskell"; Marc van Woerkom, mentored by Manuel Chakravarty

    **Unsuccessful**. According to [Don Stewart's outline](http://www.haskell.org/pipermail/haskell-cafe/2007-February/022509.html) of the 2006 SoC, this project was not completed.
- "Implement a better type checker for Yhc"; Leon P Smith, mentored by Malcolm Wallace

    **Unsuccessful**. See Language.C
- "Thin out cabal-get and integrate in GHC"; Paolo Martini, mentored by Isaac Jones

    **Successful**. Code is in Cabal, which we all know and love.
- "Unicode ByteString, Data.Rope, Parsec for generic strings"; Spencer Janssen, mentored by Don Stewart

    **Successful**. (Again, per Don.)

4 successful; 2 unsuccessful; and 2 failures.

### 2007

The [2007 homepage](http://hackage.haskell.org/trac/summer-of-code/wiki/SoC2007)

- "Darcs conflict handling"; Jason Dagit, mentored by David Roundy

    **Successful**. The work was successful in almost completely getting rid of the exponential conflict bug, and has been in the regular releases of Darcs 2.x for some time now.
- "Automated building of packages and generation of Haddock documentation"; Sascha Böhme, mentored by Ross Paterson

    **Successful**. The auto build and doc generation are long-standing and very useful parts of Hackage.
- "Rewrite the typechecker for YHC and nhc98"; Mathieu Boespflug, mentored by Malcolm Wallace

    **Successful**. According to the TMR writeup, the type-checker code has made it into (at least) YHC.
- "Cabal Configurations"; Thomas Schilling, mentored by Michael Isaac Jones

    **Successful**. Cabal configurations have been around for a while and are very useful for enabling/disabling things
- Update the Hat tracer; Kenn Knowles, mentored by Malcolm Wallace

    **Unsuccessful**. The update apparently happened, since the [Hat homepage](http://www.haskell.org/hat/) says "Version 2.06 released 2nd Oct 2008", but it is [described](http://www.haskell.org/hat/download.html) as unmaintained, and I can't seem to find any examples of people actually using Hat.
- Generalizing Parsec to ParsecT and arbitrary input (ByteStrings); Paolo Martini, mentored by Philippa Jane Cowderoy

    **Successful?**. The performance is still so terrible that few people use it.
- Shared Libraries for GHC; Clemens Fruhwirth, mentored by Simon Marlow

    **Successful?**. The situation is unclear to me, but I know that for some period dynamic linking worked for some platforms. However, it's 2010 and I still have static linking, although GHC 6.12 apparently gets dynamic linking; so I'm going to chalk this one up as a mixed success.
- "Libcurl"; Mieczysław Bąk, mentored by Bryan O'Sullivan

    **Successful**. Libcurl does exist and has been used, and is maintained. I understand it has been used, even if I personally don't know of any examples.
- "Extending GuiHaskell: An IDE for Haskell Hackers"; Asumu Takikawa, mentored by Neil David Mitchell

    **Unsuccessful**. GuiHaskell does not exist in any usable form. (The homepage summarizes the situation thusly: ["**Warning**: This project is fragile, unfinished, and I do not recommend that anyone tries using it."](http://www-users.cs.york.ac.uk/~ndm/guihaskell/))

6 successes; 1 unsuccessful; 1 failure.

#### See also

- [The Monad.Reader's](!Hawiki "The Monad Reader") [issue 9](http://www.haskell.org/wikiupload/5/5d/TMR-Issue9.pdf) covers SoC projects
- <http://www.serpentine.com/blog/2007/04/12/haskellorg-and-googles-summer-of-code/>

### 2008

The [2008 homepage](http://hackage.haskell.org/trac/summer-of-code/wiki/SoC2008) isn't so kind enough as to list all the projects as before, but it does tell us that only 7 projects were accepted by Google.

So we can work from the [code.google.com](http://code.google.com/p/google-summer-of-code-2008-haskell/downloads/list) page which lists 6:

- "C99 Parser/Pretty-Printer"; by Benedikt Huber, mentored by Iavor Diatchki

    **Successful**. The first try failed, but the second won through, and now people are doing things like [parsing the Linux kernel](http://www.galois.com/blog/2008/09/17/parsing-the-linux-kernel-with-haskell-experience-with-languagec/) with it.
- "GMap - Fast composable maps"; by Jamie Brandon

    **Successful**. GMap is on [Hackage](http://hackage.haskell.org/packages/archive/pkg-list.html), and I believe I've seen it used.
- "Haskell API Search"; Neil Mitchell

    **Successful**. The improved performance and search capability have made it into Hoogle releases.
- "Cabal 'make-like' dependency framework"; Andrea Vezzosi

    **Unsuccessful**? ([His code](http://code.haskell.org/~Saizan/cabal/) [wound](http://code.haskell.org/hbuild/) [up](http://vezzosi.blogspot.com/2008/09/even-if-this-blog-has-been-silent-since.html) becoming [hbuild](http://hackage.haskell.org/trac/hackage/wiki/HBuild), which is not on Hackage or apparently used by anyone.)
- "GHC plugins"; Maximilian Conroy Bolingbroke

    **Successful**? (As of [January 2010](http://old.nabble.com/GHC-core-plugins-td27320762.html), the patch adding plugins functionality has yet to be accepted & applied.)
- "Data parallel physics engine"; Roman Cheplyaka

    **Unsuccessful**? It seems to be finished but no use made of the actual engine (that I can see mentioned on the [engine's blog](http://physics-dph.blogspot.com/)).
- "GHC API"; Thomas Schilling

    **Unsuccessful**. Schilling's fixes went in, but they were in general minor changes (like adding the GHC monad) or bug-fixes; the GHC API remains a mess.

4 successful, 3 unsuccessful.

#### See also

- The Monad.Reader's [Issue 12](http://www.haskell.org/wikiupload/f/f0/TMR-Issue12.pdf)

### 2009

5 projects were [accepted](http://socghop.appspot.com/org/home/google/gsoc2009/haskell) this year; Darcs tried to apply in its own right was rejected.

In general, these looked good. Most of them will be widely useful -- especially the Darcs and Haddock SoCs -- or address longstanding complaints (many criticisms of laziness revolve around how unpredictable it makes memory consumption). The only one that bothers me is the EclipseFP project. I'm not sure Eclipse is common enough among Haskellers or potential Haskellers to warrant the effort, but at least the project is focused on improving an existing plugin than writing one _ab initio_. The 5 were:

- "Optimising Darcs for medium to large repositories"; by Petr Ročkai; Eric Kow, mentor

     **Unknown**. [hashed-storage](http://hackage.haskell.org/package/hashed-storage) exists and is used in Darcs, but from watching the bugtracker traffic, it's unclear whether Darcs saw a net gain from it.
- "haskell-src-exts -> haskell-src"; by Niklas Broberg; Neil Mitchell, mentor

    **Unknown**. Niklas added a large number of [patches](http://google-summer-of-code-2009-haskell.googlecode.com/files/Niklas_Broberg.tar.gz) but it's unclear to mean what practical benefit it adds. But it *does* handle comments now.

    > "This project aims to improve on my haskell-src-exts library for working with Haskell source code. The goal of the project is to have haskell-src-exts supercede the haskell-src library. The main thing involved is to add a mechanism that allows the user to conditionally choose what extensions the parser should be aware of. Further, I would extend haskell-src(-exts) with functionality to handle comments and exact layout, to allow for things like automatic code generation and refactoring."

- "Haddock improvements"; by Isaac Dupree; David Waern, mentor

    **Successful?**. Dupree's [patches](http://google-summer-of-code-2009-haskell.googlecode.com/files/IsaacA_Dupree.tar.gz) have been applied to head and apparently make cross-package links [usually work](http://haddock2009.wordpress.com/category/cross-package-documentation/).
- "Improving space profiling experience"; by Gergely Patai; Johan Tibell, mentor

    **Successful**. [hp2any](http://www.haskell.org/haskellwiki/Hp2any) seems quite alive and usable.

- "Extend EclipseFP functionality for Haskell"; by Thomas ten Cate; Thomas Schilling, mentor

    **Unsuccessful**. See [Cate's summing-up](http://eclipsefp.wordpress.com/2009/08/25/endgame/).

2 unknown, 2 successful, 1 failure.

### 2010

[7 projects](http://donsbot.wordpress.com/2010/04/26/the-7-haskell-projects-in-the-google-summer-of-code/) were accepted:

- [Improvements to Cabal's test support](http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760295); Thomas Tuegel, mentored by Johan Tibell

    **Successful**? A few packages use the provided test syntax, but to run tests, one needs the unreleased `cabal-install-0.10`. 
- [Infrastructure for a more social Hackage 2.0](http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760520); Matthew Gruen, mentored by Edward Kmett 

    **Unknown**. [Gruen's blog](http://cogracenotes.wordpress.com/) was last updated October 2010, and Hackage still hasn't switched over and gotten the new features & benefit of the rewrite. But the code exists and there is a running [public demo](http://sparky.haskell.org:8080/), so this may yet be a success.
- [A high performance HTML generation library](http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760572); Jasper Van der Jeugt, mentored by Simon Meier

    **Successful** [blaze-html](!Hackage) has been released and is actively developed; version 0.4.0.0 has [50 total reverse dependencies](http://sparky.haskell.org:8080/package/blaze-html/reverse/all) and [blaze-builder](!Hackage) has [97 reverse dependencies](http://sparky.haskell.org:8080/package/blaze-builder/reverse/all) though there's much overlap. (This site is built on [hakyll](!Hackage), which uses blaze-html.)
- [Improvements to the GHC LLVM backend](http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760615); Alp Mestanogullari, mentored by Maximilian Bolingbroke

    **Unknown**. The LLVM backend seems to still be on track to become the default GHC backend^[A development that surprises me, since I had been under the impression that most GHC work ultimately winds up being scrapped or abandoned like Liskell or Mobile Haskell.], but I don't know enough about Mestanogullari's work to decide whether it was useful or whether his work was even merged into GHC HEAD. (Comments especially welcomed on this one.)
- [Implementing the Immix Garbage Collection Algorithm](http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760695); Marco Silva, mentored by Simon Marlow

    **Unsuccessful**. The GHC repository history, as of 4 February, contains no patches adding Immix GC. Silva writes in his blog's [SoC summary](http://marcotmarcot.wordpress.com/2010/08/20/immix-on-ghc-summer-of-code-final-report/) that "Although the implementation is not mature enough to be included in the repository, I’m happy with the state it is now. I think it’s a good start, and I plan to keep working on it." (His [new blog](http://marcot.eti.br/blog/), begun in August 2010, contains no mention of Immix work.)
- [GObject-Introspection based bindings for gtk2hs](http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760750); Matthew Arsenault, mentored by Axel Simon

    **Unsuccessful**. [bindings-gobject](!Hackage)'s first release was in November 2009. Since then, exactly [one](http://sparky.haskell.org:8080/package/bindings-gobject-0.3/reverse) 2 other packages have made use of it - [binding-gts](!Hackage) and [bitspeak](!Hackage).
- [Improving Darcs's network performance](http://socghop.appspot.com/gsoc/student_project/show/google/gsoc2010/haskell/t127230760775); Alexey Levan, mentored by Petr Rockai

    **Successful**. Levan divided his SoC into 2 parts, improving Darcs's performance in fetching the many small files that make up a repository's revision history, and writing 'a smart server that can provide clients with only files they need in one request'. The 'smart server' seems to have been abandoned as not being worthwhile, but the fetching idea was implemented and will be in the [2.8 release](http://blog.darcs.net/2010/11/coming-in-darcs-28-new-features.html).

    The [basic idea](http://wiki.darcs.net/Internals/OptimizeHTTP) is to combine all the small files into a single [tarball](!Wikipedia "tar (file format)") which can be downloaded at full speed, and avoid the latency of many roundtrips. The 2.8 release description claims that when `darcs optimize --http` was used on the Darcs repository, a full download went from 40 minutes to 3 minutes. This feature would not be enabled by default, but the gain for larger repositories would be large enough that I feel comfortable classifying it as a successful SoC.

#### Predicting 2010 results

Borrowing from our [3 cardinal sins](#haskell-roundup) of SoCs, what predictions can we make?

Most of the 7 SoCs are laudably focused on an existing application. You don't need to justify a speedup of normal Darcs operations because there's an installed base of Darcs users that will benefit; a new GC for GHC or a LLVM backend will benefit every Haskeller; better Cabal support for testing may go unused by many package authors who either have no tests or don't want to bother - but a fair number will bother, and it will get maintained as part of Cabal, and similarly for the Hackage 2.0 project.

The Immix GC strikes me as a very challenging summer project; a GC is one of the most low-level pieces of a functional language and is intertwined with all sorts of code and considerations. It would not surprise me if that project wound up just getting a little closer to a working Immix GC but not producing a production-quality GC scheduled to come to compilers near you.

2 in particular concern me as potentially falling prey to sins #2 & 3: the GObject-binder tool, and the high-performance HTML library:

1. Let's assume that the HTML library does wind up as being faster than existing libraries, and as useful - that compromises don't destroy its utility. Who will use it? It will almost surely have an API different enough from existing libraries that a conversion will be painful. There are roughly 42 users of the existing [xhtml](http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/package/xhtml)-generating library; will their authors wish to embrace a cutting-edge infant library? Is HTML generation even much of a bottleneck for them? (Speaking just for Gitit, Pandoc and its HTML generation are not usually a bottleneck.)
2. The case against the GObject project presents itself; GTK2Hs isn't as widely used as one would expect, and this seems to be due to the difficulty of installation and its general complexity. So there are few users of existing libraries; would there be more users for those libraries no one has bothered to bind nor yet clamored for? (This project might fall afoul of sin #1, but I do not know how difficult the GObject data is to interpret.)

#### 2010 results

As of February 2010, I grade the 7 SoC for 2010 as follows: 3 successes, 2 unknown, and 2 unsuccessful. (One unknown, Hackage 2.0, will probably turn out to be a success once it goes live as the main Hackage site. I am agnostic about whether I will ultimately judge the LLVM SoC a success or not.) As one would hope, the results seem to be better than the results for 2008 or 2009.

Of my original predictions, I think I was completely right about the GObject SoC, right about the Immix GC and Darcs, semi-right about Hackage 2.0 & Cabal testing support, and completely wrong about the HTML/`blaze` SoC. (I am not sure why I was wrong about the last.)

### Haskell roundup

So, what lessons can we learn from the 3 SoCs? It seems to me like there are roughly 3 groups explanations for failure. They are:

1) _Hubris_. GuiHaskell is probably a good example; it is essentially a bare-bones IDE, from its description. It is expecting a bit much of a single student in a single summer to write *that*!
2) _Unclear use_. HsJudy is my example here. There are already so many arrays and array types in Haskell! What does HsJudy bring to the table that justifies a FFI dependency? Who's going to use it? Pugs initially did apparently, but perhaps that's just because it was there - when I looked at Pugs/HsJudy in 2007, certainly Pugs had no need of it. (The data parallel physics engine is probably another good example. Is it just a benchmark for the GHC developers? Is it intended for actual games? If the former, why is it a SoC project, and if the latter, isn't that a little hubristic?)
3) _Lack of propaganda_. One of the reasons Don Stewart's bytestring library is so great is his relentless evangelizing, which convinces people to actually take the effort to learn and use Bytestrings; eventually by network effects, the whole Haskell community is affected & improved[^academic]. Some of these SoC projects suffer from a distinct lack of community buy-in - who used HaskellNet? Who used Hat when it was updated? Indifference can be fatal, and can defeat the point of a project. What good is a library that no one uses? These aren't academic research projects which accomplish their task just by existing, after all. They're supposed to be useful to real Haskellers.

### Future SoCs

There are 2 major collections of ideas for future SoC projects:

- The [Haskell proposals](http://www.reddit.com/r/haskell_proposals/top/?t=all) [subreddit](http://www.urlesque.com/2011/01/06/whats-a-subreddit-how-reddit-works/), with ideas ranked by popularity
- the [Haskell Summer of Code](http://hackage.haskell.org/trac/summer-of-code/report/1) [trac](!Wikipedia)

Let's look at the first 12 and see whether they're good ideas, bad ideas, or indifferent.

1. [port GHC to the ARM architecture](http://www.reddit.com/r/haskell_proposals/comments/7ihso/an_arm_port_of_ghc_that_works_so_we_can_program/): It would be a good thing if we could easily compile our Haskell programs for ARM, which is used in many cellphones, but an even better idea would [using the LLVM backend](http://www.reddit.com/r/haskell_proposals/comments/b7ol7/use_the_llvm_backend_to_turn_ghc_into_a/) to [crosscompile](!Wikipedia). It would be somewhat tricky, but LLVM already has fairly solid [cross-compilation support](http://wiki.llvm.org/HowTo:_LLVM-based_cross_compiler), and making GHC capable of using it seems like a reasonable project for a student to tackle.
2. ["Implement overlap and exhaustiveness checking for pattern matching"](http://hackage.haskell.org/trac/summer-of-code/ticket/1579): this seems both quite challenging and also a specialized use. I use [GADTs](http://haskell.org/haskellwiki/Generalised_algebraic_datatype) rarely, but I suspect that those writing GADT code rarely make overlap or omission errors.
3. [Incremental garbage collection](http://www.reddit.com/r/haskell_proposals/comments/d1ksj/incremental_garbage_collection_so_i_can_make_some/): this *may* be a good idea depending on how much of the code was already written. But I fear that this would go the way of the Immix GC SoC and would be a bad idea.
4. ["ThreadScope with custom probes"](http://hackage.haskell.org/trac/summer-of-code/ticket/1584): I don't understand the description and can't judge it.
5. ["A simple, sane, comprehensive Date/Time API"](http://www.reddit.com/r/haskell_proposals/comments/b8rlh/a_simple_sane_comprehensive_datetime_api/): having puzzled over date-time libraries before, I'm all for this one! It's a well-defined problem, within the scope of a summer, and meets a need. Its only problem is that it doesn't sound sexy or cool.
6. ["Combine Threadscope with Heap Profiling Tools"](http://hackage.haskell.org/trac/summer-of-code/ticket/1585): Uncertain. Going by the [Arch download statistics](http://www.galois.com/~dons/arch-haskell-status.html), Threadscope is downloaded more often than one would expect, so perhaps integration would be useful.
7. ["Haddock with embedded wiki feature, a la RWH, so we can collaborate on improving the documentation"](http://www.reddit.com/r/haskell_proposals/comments/7qnwq/haddock_with_embedded_wiki_feature_a_la_rwh_so_we/): This is a bad idea mostly because there are so many diverging ideas and possible implementations - it's just not clear what one would do. Is it some sort of Haddock server? A Gitit wiki with clever hooks? Some lightweight in-browser editor combined with Darcs?
8. ["HTTP Library Replacement"](http://hackage.haskell.org/trac/summer-of-code/ticket/1122): A good idea, assuming the linked attempts and alternate libraries haven't already solved the issue.
9. ["Using Type Inference to Highlight Code *Properly*"](http://www.reddit.com/r/haskell_proposals/comments/biaew/using_type_inference_to_highlight_code_properly/): The difficult part is accessing the type information of an identifier inside a GHCi sessions - a problem probably already solved by [scion](!Hackage). Colorizing the display of a snippet is trivial. So this would make a bad SoC. 
10. ["Transformation and Optimisation Tool"](http://hackage.haskell.org/trac/summer-of-code/ticket/1536): This initially sounds attractive, but previous refactoring tools have been ignored. The tools that have gotten uptake are things like GHC's `-Wall` (which warns about possible semantic issues) and [hlint](!Hackage) (which warns about style issues and redundancy with standard library functions) - not like Hera.
11. ["Webkit-based browser written in Haskell, similar in architecture to Xmonad"](http://www.reddit.com/r/haskell_proposals/comments/98vxo/webkitbased_browser_written_in_haskell_similar_in/): This is probably the worst single idea in the whole bunch. A web browser these days is an entire operating system, but worse, one in which one must supply and maintain the userland as well; it is a thankless task that will not benefit the Haskell community (except incidentally through supporting libraries), nor a task it is uniquely equipped for. It is an infinite time sink - the only thing worse than this sort of SoC failing would be it succeeding. 
12. ["Add NVIDIA CUDA backend for Data Parallel Haskell"](http://hackage.haskell.org/trac/summer-of-code/ticket/1537): DPH is rarely used; a CUDA backend would be even more rarely utilized; CUDA has a reputation for being difficult to coax performance out of; and difficulties would likely be exacerbated by the usual Haskell issues with space usage & laziness. All in all, there are many better SoCs.

#### Don Stewart's view

[Don Stewart writes](http://www.haskell.org/pipermail/haskell-cafe/2009-February/055531.html) in reply to the foregoing:

> We explicitly pushed harder in 2008 to clarify and simplify the goals of the projects, ensure adequate *prior Haskell experience* and to focus on libraries and tools that directly benefit the communtity. [_sic_]
>
> And our success rate was much higher.
>
> So: look for things that benefit the largest number of Haskell developers and users, and from students with proven Haskell development experience. You can't learn Haskell from zero on the job, during SoC.

[^complaints]: I can hear the wankers in the peanut gallery - "Yeah, and it's been buggy ever since!" Hush you. (You can read Waern's reply to this [here](http://www.haskell.org/pipermail/haskell-cafe/2009-February/055500.html).)
[^academic]: Many good and worthwhile projects suffer this fate because of their academic origins. There's no reward for someone who creates a great technique or library and gets the wider community to adopt it as standard. As far as the Haskell community is concerned, one Don Stewart is worth more than a dozen Oleg Kiselyovs; [Oleg's work](http://okmij.org/ftp/) is mindblowingly awesome in quantity and quality, everyone acknowledges, but how often does anyone actually use any of it?

    ([Iteratees](http://okmij.org/ftp/Streams.html) may be the exception; although there are somewhere upwards of [5 implementations](http://john-millikin.com/articles/understanding-iteratees/) by Oleg and others, the original [iteratees](!Hackage) has picked up [10 reverse dependencies](http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/iteratee-0.7.0.0), and iteratees may one day become as widely used as `bytestring`.)