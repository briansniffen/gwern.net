# Chapter 1.3: Formulating Abstractions with Higher-Order Procedures

[1.3](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3) presents the following higher-order function:

~~~~{.scheme}
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
~~~~

It's worth noting that `sum` is not as general as it could be. It hardwires in a terminal value of 0, and the `+` and `>` operator & conditional. Its type would be something like `sum :: (Num a) => (a -> a) -> a -> (a -> a) -> a -> a`; a more general approach would be to require a general boolean function rather than a particular value.

[iterate](!Hoogle) is similar, but note that it has a type signature that initially seems simpler and less powerful: `iterate :: (a -> a) -> a -> [a]`. Surely the more parameterizable a function, the more general it is? `iterate` has but 1 function argument, while `sum` has 2.

But `iterate` has 2 arguments in a sense, when we remember how it generates an infinite list - we can think of it as the zeroth entry is `x`, the first entry `f x`, the 2^nd^ entry is `f (f x)`, the 3^rd^ entry is `f (f (f x))`, and so on^[This is the idea; the actual implementation is more syntactically efficient: `iterate f x = x : iterate f (f x)`.]. The missing function is whatever is calling `iterate` and using its values; in `sum`, the termination is explicitly handled by a function because the evaluation scheme in Scheme is strict.

Here's an example. If we called `iterate (^3) 2`, we would get the infinite list  `[2,8,512,134217728,2417851639229258349412352..]`; but `sum` clearly has a stopping case. So we [compose](!Wikipedia "Function composition") `iterate` with [takeWhile](!Hoogle): `iterate` gets the seed value and the knowledge of how to keep changing the seed value, and `takeWhile` gets the knowledge of when the seed value has changed enough. 

This will be useful for approximation. But note that it's not useful for straight summing like `sum-cubes`, because `iterate` uses the passed-in function to generate the next target from the old target, while `sum` has the passed-in function doing something else entirely (moving from old to new is hardwired to use the function `(+1)`). So if we wrote the obvious Haskell `summation` and `sumCube` definitions, they would be utterly wrong: `sumCube 1 10` will loop because $1^3=1$, and if we tried `sumCube 2 10`, it'd still be wrong - we'd get `[2,8]` because the test will return false for $8^3<10$.

~~~~{.haskell}
summation cond next seed = takeWhile cond $ iterate next seed
sumCube start end = summation (< end) (^3) start
~~~~

To rewrite `sum`, we need to pay attention to what dependencies are where. Given the parameters `a b`, we can get the targets with just `[a..b]`; then, we take whatever function and `map` it onto the targets: `foo f a b = map f [a..b]`; then we fold the resulting list into a final answer: `foo f a b = sum $ map f [a..b]`, and finally:

~~~~{.haskell}
sumCube start end = foo (^3) start end
~~~~

But `sum` has 4 parameters, not 3. The `[a..b]` hides the `(+1)` or `inc` specification.

## Exercise 1.30

Our `sum` rewritten for multiplication is of course (modulo better variable names):

~~~~{.scheme}
(define (product f begin increase end)
  (if (> begin end)
      1
      (* (f begin)
         (product f (increase begin) increase end))))
~~~~

All we had to change was the 'seed' and the inner function (`*` versus `+`).

Writing a `factorial` requires a little imagination, but here Haskell prevents me from having to think too much; Haskell's [product](!Hoogle) has the type signature `Num a => [a] -> a`, so immediately the obvious way to define `factorial` is to generate a list of the right length:

~~~~{.haskell}
factorial n = product [1..n]
~~~~

How can we generate such a list with this Scheme function? We have to pass in 2 functions and 2 integers which will somehow do this.

The answer is to make our first function *do nothing*, and the second function just increment the seed; an example:

~~~~{.scheme}
(product (lambda (a) a) 1 (lambda (g) (+ g 1)) 5)
~>
120
~~~~

The `(lambda (a) a)` is bound to the variable `f`, which gets called on the first multiplication, but does nothing - exactly as needed. Then `(lambda (g) (+ g 1))` takes care of generating the next entry in the Scheme equivalent of `[1..n]`.

### Monoids

A worldly Haskeller will look at this and immediately think, 'an initial seed value, and some way of combining values... could this idea be a *[monoid](!Wikipedia)*?!'

As [sigfpe's](http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html) excellent tutorial on monoids will tell us, yes - this is a monoid. In fact, integers (our topic) form two different monoids, one for addition (Sum) and one for multiplication (Product).

The `Monoid` typeclass requires the following:

~~~~{.haskell}
class Monoid a where
   mempty  :: a
   mappend :: a -> a -> a
   mconcat :: [a] -> a
~~~~

`mempty` is our 'seed' value - it is the identity. For Sum, $0+n=n$; for Product, $1*n=n$.

`mappend` is how to combine 2 such monoids. Both `(+)` and `(*)` have the right type signature: `Num a => a -> a -> a`.

`mconcat` can be automatically defined from `mempty` and `mappend` - you just prefix a `mempty` onto the list, and then proceed to `mappend` your way down it.

This works out perfectly for `+` and `*`:

~~~~{.haskell}
mconcat [1..5] -- for Product
~>
fold [mempty, 1, 2, 3, 4, 5] -- not the actual fold; artistic license
~>
mempty `mappend` 1 `mappend` 2 `mappend` 3 `mappend` 4 `mappend 5
~>
1 `mappend` 1 `mappend` 2 `mappend` 3 `mappend` 4 `mappend 5
~>
1 * 1 * 2 * 3 * 4 * 5
~>
120

mconcat [1..5] -- for Sum
~>
fold [mempty, 1, 2, 3, 4, 5] -- not the actual fold; artistic license
~>
mempty `mappend` 1 `mappend` 2 `mappend` 3 `mappend` 4 `mappend 5
~>
0 `mappend` 1 `mappend` 2 `mappend` 3 `mappend` 4 `mappend 5
~>
15
~~~~

Notice that right up to the final steps everything was the same.

If we wanted to use the Sum or Product monoids in actual code, we would use the [Data.Monoid](!Hoogle) library, which gives us Sum and Product on everything in the [Num](!Hoogle) typeclass:

~~~~{.haskell}
import Data.Monoid
...
mconcat (map Product [1..5])
~>
Product {getProduct = 120}

mconcat (map Sum [1..5])
~>
Sum {getSum = 15}
~~~~

So, `mconcat` is basically our `sum` or `product` but abstracted away from a specific monoid and how to generate the `[a]` argument.

A great many data structures or datatypes are monoids; they're worth knowing about.